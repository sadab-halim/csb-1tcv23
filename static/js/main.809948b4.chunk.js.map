{"version":3,"sources":["selectMenu.js","utils/caretHelpers.js","editableBlock.js","utils/uid.js","editablePage.js","index.js"],"names":["allowedTags","id","tag","label","SelectMenu","props","keyDownHandler","bind","state","command","items","selectedItem","document","addEventListener","this","prevProps","prevState","matchSorter","keys","setState","removeEventListener","e","selected","key","preventDefault","onSelect","close","substring","length","prevSelected","nextSelected","x","position","positionAttributes","top","y","left","className","style","map","item","isSelected","indexOf","role","tabIndex","onClick","React","Component","setCaretToEnd","element","range","createRange","selection","window","getSelection","selectNodeContents","collapse","removeAllRanges","addRange","focus","EditableBlock","onChangeHandler","onKeyDownHandler","onKeyUpHandler","openSelectMenuHandler","closeSelectMenuHandler","tagSelectionHandler","contentEditable","createRef","htmlBackup","html","previousKey","selectMenuIsOpen","selectMenuPosition","htmlChanged","tagChanged","updatePage","target","value","addBlock","ref","current","deleteBlock","rangeCount","getRangeAt","cloneRange","rect","getClientRects","getCaretCoordinates","innerRef","tagName","onChange","onKeyDown","onKeyUp","uid","Date","now","toString","Math","random","substr","initialBlock","EditablePage","updatePageHandler","addBlockHandler","deleteBlockHandler","blocks","updatedBlock","index","b","updatedBlocks","currentBlock","newBlock","splice","nextElementSibling","previousBlock","previousElementSibling","block","rootElement","getElementById","ReactDOM","render","StrictMode","aria-label"],"mappings":"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","file":"static/js/main.809948b4.chunk.js","sourcesContent":["import React from \"react\";\r\nimport { matchSorter } from \"match-sorter\";\r\n\r\nconst MENU_HEIGHT = 150;\r\nconst allowedTags = [\r\n  {\r\n    id: \"page-title\",\r\n    tag: \"h1\",\r\n    label: \"Page Title\"\r\n  },\r\n  {\r\n    id: \"heading\",\r\n    tag: \"h2\",\r\n    label: \"Heading\"\r\n  },\r\n  {\r\n    id: \"subheading\",\r\n    tag: \"h3\",\r\n    label: \"Subheading\"\r\n  },\r\n  {\r\n    id: \"paragraph\",\r\n    tag: \"p\",\r\n    label: \"Paragraph\"\r\n  }\r\n];\r\n\r\nclass SelectMenu extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.keyDownHandler = this.keyDownHandler.bind(this);\r\n    this.state = {\r\n      command: \"\",\r\n      items: allowedTags,\r\n      selectedItem: 0\r\n    };\r\n  }\r\n\r\n  // Attach a key listener to add any given key to the command\r\n  componentDidMount() {\r\n    document.addEventListener(\"keydown\", this.keyDownHandler);\r\n  }\r\n\r\n  // Whenever the command changes, look for matching tags in the list\r\n  componentDidUpdate(prevProps, prevState) {\r\n    const command = this.state.command;\r\n    if (prevState.command !== command) {\r\n      const items = matchSorter(allowedTags, command, { keys: [\"tag\"] });\r\n      this.setState({ items: items });\r\n    }\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    document.removeEventListener(\"keydown\", this.keyDownHandler);\r\n  }\r\n\r\n  keyDownHandler(e) {\r\n    const items = this.state.items;\r\n    const selected = this.state.selectedItem;\r\n    const command = this.state.command;\r\n\r\n    switch (e.key) {\r\n      case \"Enter\":\r\n        e.preventDefault();\r\n        this.props.onSelect(items[selected].tag);\r\n        break;\r\n      case \"Backspace\":\r\n        if (!command) this.props.close();\r\n        this.setState({ command: command.substring(0, command.length - 1) });\r\n        break;\r\n      case \"ArrowUp\":\r\n        e.preventDefault();\r\n        const prevSelected = selected === 0 ? items.length - 1 : selected - 1;\r\n        this.setState({ selectedItem: prevSelected });\r\n        break;\r\n      case \"ArrowDown\":\r\n      case \"Tab\":\r\n        e.preventDefault();\r\n        const nextSelected = selected === items.length - 1 ? 0 : selected + 1;\r\n        this.setState({ selectedItem: nextSelected });\r\n        break;\r\n      default:\r\n        this.setState({ command: this.state.command + e.key });\r\n        break;\r\n    }\r\n  }\r\n\r\n  render() {\r\n    // Define the absolute position before rendering\r\n    const x = this.props.position.x;\r\n    const y = this.props.position.y - MENU_HEIGHT;\r\n    const positionAttributes = { top: y, left: x };\r\n\r\n    return (\r\n      <div className=\"SelectMenu\" style={positionAttributes}>\r\n        <div className=\"Items\">\r\n          {this.state.items.map((item, key) => {\r\n            const selectedItem = this.state.selectedItem;\r\n            const isSelected = this.state.items.indexOf(item) === selectedItem;\r\n            return (\r\n              <div\r\n                className={isSelected ? \"Selected\" : null}\r\n                key={key}\r\n                role=\"button\"\r\n                tabIndex=\"0\"\r\n                onClick={() => this.props.onSelect(item.tag)}\r\n              >\r\n                {item.label}\r\n              </div>\r\n            );\r\n          })}\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default SelectMenu;\r\n","export const getCaretCoordinates = () => {\r\n  let x, y;\r\n  const isSupported = typeof window.getSelection !== \"undefined\";\r\n  if (isSupported) {\r\n    const selection = window.getSelection();\r\n    // Check if there is a selection (i.e. cursor in place)\r\n    if (selection.rangeCount !== 0) {\r\n      // Clone the range\r\n      const range = selection.getRangeAt(0).cloneRange();\r\n      // Collapse the range to the start, so there are not multiple chars selected\r\n      range.collapse(false);\r\n      // getCientRects returns all the positioning information we need\r\n      const rect = range.getClientRects()[0];\r\n      if (rect) {\r\n        x = rect.left;\r\n        y = rect.top;\r\n      }\r\n    }\r\n  }\r\n  return { x, y };\r\n};\r\n\r\nexport const setCaretToEnd = (element) => {\r\n  // Create a new range\r\n  const range = document.createRange();\r\n  // Get the selection object\r\n  const selection = window.getSelection();\r\n  // Select all the content from the contenteditable element\r\n  range.selectNodeContents(element);\r\n  // Collapse it to the end, i.e. putting the cursor to the end\r\n  range.collapse(false);\r\n  // Clear all existing selections\r\n  selection.removeAllRanges();\r\n  // Put the new range in place\r\n  selection.addRange(range);\r\n  // Set the focus to the contenteditable element\r\n  element.focus();\r\n};\r\n","import React from \"react\";\r\nimport ContentEditable from \"react-contenteditable\";\r\n\r\nimport \"./styles.css\";\r\nimport SelectMenu from \"./selectMenu\";\r\n\r\nimport { getCaretCoordinates, setCaretToEnd } from \"./utils/caretHelpers\";\r\n\r\nconst CMD_KEY = \"/\";\r\n\r\nclass EditableBlock extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.onChangeHandler = this.onChangeHandler.bind(this);\r\n    this.onKeyDownHandler = this.onKeyDownHandler.bind(this);\r\n    this.onKeyUpHandler = this.onKeyUpHandler.bind(this);\r\n    this.openSelectMenuHandler = this.openSelectMenuHandler.bind(this);\r\n    this.closeSelectMenuHandler = this.closeSelectMenuHandler.bind(this);\r\n    this.tagSelectionHandler = this.tagSelectionHandler.bind(this);\r\n    this.contentEditable = React.createRef();\r\n    this.state = {\r\n      htmlBackup: null, // needed to store the html temporarely\r\n      html: \"\",\r\n      tag: \"p\",\r\n      previousKey: \"\",\r\n      selectMenuIsOpen: false,\r\n      selectMenuPosition: {\r\n        x: null,\r\n        y: null\r\n      }\r\n    };\r\n  }\r\n\r\n  componentDidMount() {\r\n    this.setState({ html: this.props.html, tag: this.props.tag });\r\n  }\r\n\r\n  // Update the page component if one of the following is true:\r\n  // 1. user has changed the html content\r\n  // 2. user has changed the tag\r\n  componentDidUpdate(prevProps, prevState) {\r\n    const htmlChanged = prevState.html !== this.state.html;\r\n    const tagChanged = prevState.tag !== this.state.tag;\r\n    if (htmlChanged || tagChanged) {\r\n      this.props.updatePage({\r\n        id: this.props.id,\r\n        html: this.state.html,\r\n        tag: this.state.tag\r\n      });\r\n    }\r\n  }\r\n\r\n  onChangeHandler(e) {\r\n    this.setState({ html: e.target.value });\r\n  }\r\n\r\n  onKeyDownHandler(e) {\r\n    if (e.key === CMD_KEY) {\r\n      // If the user starts to enter a command, we store a backup copy of\r\n      // the html. We need this to restore a clean version of the content\r\n      // after the content type selection was finished.\r\n      this.setState({ htmlBackup: this.state.html });\r\n    }\r\n    if (e.key === \"Enter\") {\r\n      // While pressing \"Enter\" should add a new block to the page, we\r\n      // still want to allow line breaks by pressing \"Shift-Enter\"\r\n      if (this.state.previousKey !== \"Shift\" && !this.state.selectMenuIsOpen) {\r\n        e.preventDefault();\r\n        this.props.addBlock({\r\n          id: this.props.id,\r\n          ref: this.contentEditable.current\r\n        });\r\n      }\r\n    }\r\n    if (e.key === \"Backspace\" && !this.state.html) {\r\n      // If there is no content, we delete the block by pressing \"Backspace\",\r\n      // just as we would remove a line in a regular text container\r\n      e.preventDefault();\r\n      this.props.deleteBlock({\r\n        id: this.props.id,\r\n        ref: this.contentEditable.current\r\n      });\r\n    }\r\n    // Store the key to detect combinations like \"Shift-Enter\" later on\r\n    this.setState({ previousKey: e.key });\r\n  }\r\n\r\n  // The openSelectMenuHandler function needs to be invoked on key up. Otherwise\r\n  // the calculation of the caret coordinates does not work properly.\r\n  onKeyUpHandler(e) {\r\n    if (e.key === CMD_KEY) {\r\n      this.openSelectMenuHandler();\r\n    }\r\n  }\r\n\r\n  // After openening the select menu, we attach a click listener to the dom that\r\n  // closes the menu after the next click - regardless of outside or inside menu.\r\n  openSelectMenuHandler() {\r\n    const { x, y } = getCaretCoordinates();\r\n    this.setState({\r\n      selectMenuIsOpen: true,\r\n      selectMenuPosition: { x, y }\r\n    });\r\n    document.addEventListener(\"click\", this.closeSelectMenuHandler);\r\n  }\r\n\r\n  closeSelectMenuHandler() {\r\n    this.setState({\r\n      htmlBackup: null,\r\n      selectMenuIsOpen: false,\r\n      selectMenuPosition: { x: null, y: null }\r\n    });\r\n    document.removeEventListener(\"click\", this.closeSelectMenuHandler);\r\n  }\r\n\r\n  // Restore the clean html (without the command), focus the editable\r\n  // with the caret being set to the end, close the select menu\r\n  tagSelectionHandler(tag) {\r\n    this.setState({ tag: tag, html: this.state.htmlBackup }, () => {\r\n      setCaretToEnd(this.contentEditable.current);\r\n      this.closeSelectMenuHandler();\r\n    });\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <>\r\n        {this.state.selectMenuIsOpen && (\r\n          <SelectMenu\r\n            position={this.state.selectMenuPosition}\r\n            onSelect={this.tagSelectionHandler}\r\n            close={this.closeSelectMenuHandler}\r\n          />\r\n        )}\r\n        <ContentEditable\r\n          className=\"Block\"\r\n          innerRef={this.contentEditable}\r\n          html={this.state.html}\r\n          tagName={this.state.tag}\r\n          onChange={this.onChangeHandler}\r\n          onKeyDown={this.onKeyDownHandler}\r\n          onKeyUp={this.onKeyUpHandler}\r\n        />\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\nexport default EditableBlock;\r\n","const uid = () => {\r\n  return Date.now().toString(36) + Math.random().toString(36).substr(2);\r\n};\r\n\r\nexport default uid;\r\n","import React from \"react\";\r\n\r\nimport \"./styles.css\";\r\nimport EditableBlock from \"./editableBlock\";\r\n\r\nimport uid from \"./utils/uid\";\r\nimport { setCaretToEnd } from \"./utils/caretHelpers\";\r\n\r\nconst initialBlock = { id: uid(), html: \"\", tag: \"p\" };\r\n\r\nclass EditablePage extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.updatePageHandler = this.updatePageHandler.bind(this);\r\n    this.addBlockHandler = this.addBlockHandler.bind(this);\r\n    this.deleteBlockHandler = this.deleteBlockHandler.bind(this);\r\n    this.state = { blocks: [initialBlock] };\r\n  }\r\n\r\n  updatePageHandler(updatedBlock) {\r\n    const blocks = this.state.blocks;\r\n    const index = blocks.map((b) => b.id).indexOf(updatedBlock.id);\r\n    const updatedBlocks = [...blocks];\r\n    updatedBlocks[index] = {\r\n      ...updatedBlocks[index],\r\n      tag: updatedBlock.tag,\r\n      html: updatedBlock.html\r\n    };\r\n    this.setState({ blocks: updatedBlocks });\r\n  }\r\n\r\n  addBlockHandler(currentBlock) {\r\n    const newBlock = { id: uid(), html: \"\", tag: \"p\" };\r\n    const blocks = this.state.blocks;\r\n    const index = blocks.map((b) => b.id).indexOf(currentBlock.id);\r\n    const updatedBlocks = [...blocks];\r\n    updatedBlocks.splice(index + 1, 0, newBlock);\r\n    this.setState({ blocks: updatedBlocks }, () => {\r\n      currentBlock.ref.nextElementSibling.focus();\r\n    });\r\n  }\r\n\r\n  deleteBlockHandler(currentBlock) {\r\n    // Only delete the block, if there is a preceding one\r\n    const previousBlock = currentBlock.ref.previousElementSibling;\r\n    if (previousBlock) {\r\n      const blocks = this.state.blocks;\r\n      const index = blocks.map((b) => b.id).indexOf(currentBlock.id);\r\n      const updatedBlocks = [...blocks];\r\n      updatedBlocks.splice(index, 1);\r\n      this.setState({ blocks: updatedBlocks }, () => {\r\n        setCaretToEnd(previousBlock);\r\n        previousBlock.focus();\r\n      });\r\n    }\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div className=\"Page\">\r\n        {this.state.blocks.map((block, key) => {\r\n          return (\r\n            <EditableBlock\r\n              key={key}\r\n              id={block.id}\r\n              tag={block.tag}\r\n              html={block.html}\r\n              updatePage={this.updatePageHandler}\r\n              addBlock={this.addBlockHandler}\r\n              deleteBlock={this.deleteBlockHandler}\r\n            />\r\n          );\r\n        })}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default EditablePage;\r\n","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\n\r\nimport EditablePage from \"./editablePage\";\r\n\r\nconst rootElement = document.getElementById(\"root\");\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <h1 className=\"Logo\">notion.clone</h1>\r\n    <p className=\"Intro\">\r\n      Helloo{\" \"}\r\n      <span role=\"img\" aria-label=\"greetings\" className=\"Emoji\">\r\n        ðŸ‘‹\r\n      </span>{\" \"}\r\n      You can add content below. Type <span className=\"Code\">/</span> to see\r\n      available elements.\r\n    </p>\r\n    <EditablePage />\r\n  </React.StrictMode>,\r\n  rootElement\r\n);\r\n"],"sourceRoot":""}